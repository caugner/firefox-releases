# HG changeset patch
# User Alex Chronopoulos <achronop@gmail.com>
# Parent  39bcb53470bc0dddf61cf1cae41f02a07ddec53c
Bug 1311911 - Calculate silence frames needed in the input. r=jesup

diff --git a/media/libcubeb/src/cubeb_audiounit.cpp b/media/libcubeb/src/cubeb_audiounit.cpp
--- a/media/libcubeb/src/cubeb_audiounit.cpp
+++ b/media/libcubeb/src/cubeb_audiounit.cpp
@@ -160,18 +160,19 @@ struct cubeb_stream {
   /* User pointer of data_callback */
   void * user_ptr;
   /* Format descriptions */
   AudioStreamBasicDescription input_desc;
   AudioStreamBasicDescription output_desc;
   /* I/O AudioUnits */
   AudioUnit input_unit;
   AudioUnit output_unit;
-  /* Sample rate of input device*/
+  /* I/O device sample rate */
   Float64 input_hw_rate;
+  Float64 output_hw_rate;
   owned_critical_section mutex;
   /* Hold the input samples in every
    * input callback iteration */
   auto_array_wrapper * input_linear_buffer;
   /* Frames on input buffer */
   uint32_t input_buffer_frames;
   /* Frame counters */
   uint64_t frames_played;
@@ -369,19 +370,21 @@ audiounit_output_callback(void * user_pt
     return noErr;
   }
   /* Get output buffer. */
   output_buffer = outBufferList->mBuffers[0].mData;
   /* If Full duplex get also input buffer */
   if (stm->input_unit != NULL) {
     /* Output callback came first */
     if (stm->frames_read == 0) {
-      LOG("Output callback came first send silent.");
-      stm->input_linear_buffer->push_silence(stm->input_buffer_frames *
-                                            stm->input_desc.mChannelsPerFrame);
+      uint32_t min_input_frames_required = ceilf(stm->input_hw_rate / stm->output_hw_rate *
+                                                                      stm->input_buffer_frames);
+      LOG("Output callback came first pushed %u frames of input silence.", min_input_frames_required);
+      stm->input_linear_buffer->push_silence(min_input_frames_required *
+                                             stm->input_desc.mChannelsPerFrame);
     }
     /* Input samples stored previously in input callback. */
     if (stm->input_linear_buffer->length() == 0) {
       /* Do nothing, there should be enough pre-buffered data to consume. */
       LOG("Input hole. Requested more input than ouput.");
     }
     // The input buffer
     input_buffer = stm->input_linear_buffer->data();
@@ -1153,31 +1156,35 @@ audiounit_stream_init(cubeb * context,
   /* Silently clamp the latency down to the platform default, because we
    * synthetize the clock from the callbacks, and we want the clock to update
    * often. */
   latency_frames = audiounit_clamp_latency(stm, latency_frames);
   assert(latency_frames > 0);
 
   /* Setup Input Stream! */
   if (input_stream_params != NULL) {
+    LOG("(%p) Opening input side: rate %u, channels %u, format %d, latency in frames %u.",
+        stm, stm->input_stream_params.rate, stm->input_stream_params.channels,
+        stm->input_stream_params.format, stm->latency_frames);
     /* Get input device sample rate. */
     AudioStreamBasicDescription input_hw_desc;
     size = sizeof(AudioStreamBasicDescription);
     r = AudioUnitGetProperty(stm->input_unit,
                             kAudioUnitProperty_StreamFormat,
                             kAudioUnitScope_Input,
                             AU_IN_BUS,
                             &input_hw_desc,
                             &size);
     if (r != noErr) {
       PRINT_ERROR_CODE("AudioUnitGetProperty/input/kAudioUnitProperty_StreamFormat", r);
       audiounit_stream_destroy(stm);
       return CUBEB_ERROR;
     }
     stm->input_hw_rate = input_hw_desc.mSampleRate;
+    LOG("(%p) Input device sampling rate: %.2f", stm, stm->input_hw_rate);
 
     /* Set format description according to the input params. */
     r = audio_stream_desc_init(&stm->input_desc, input_stream_params);
     if (r != CUBEB_OK) {
       LOG("Setting format description for input failed.");
       audiounit_stream_destroy(stm);
       return r;
     }
@@ -1253,16 +1260,19 @@ audiounit_stream_init(cubeb * context,
       audiounit_stream_destroy(stm);
       return CUBEB_ERROR;
     }
     LOG("Input audiounit init successfully.");
   }
 
   /* Setup Output Stream! */
   if (output_stream_params != NULL) {
+    LOG("(%p) Opening output side: rate %u, channels %u, format %d, latency in frames %u.",
+        stm, stm->output_stream_params.rate, stm->output_stream_params.channels,
+        stm->output_stream_params.format, stm->latency_frames);
     r = audio_stream_desc_init(&stm->output_desc, output_stream_params);
     if (r != CUBEB_OK) {
       LOG("Could not initialize the audio stream description.");
       audiounit_stream_destroy(stm);
       return r;
     }
 
     /* Get output device sample rate. */
@@ -1275,16 +1285,18 @@ audiounit_stream_init(cubeb * context,
                              AU_OUT_BUS,
                              &output_hw_desc,
                              &size);
     if (r != noErr) {
       PRINT_ERROR_CODE("AudioUnitGetProperty/output/tkAudioUnitProperty_StreamFormat", r);
       audiounit_stream_destroy(stm);
       return CUBEB_ERROR;
     }
+    stm->output_hw_rate = output_hw_desc.mSampleRate;
+    LOG("(%p) Output device sampling rate: %.2f", stm, output_hw_desc.mSampleRate);
 
     r = AudioUnitSetProperty(stm->output_unit,
                              kAudioUnitProperty_StreamFormat,
                              kAudioUnitScope_Input,
                              AU_OUT_BUS,
                              &stm->output_desc,
                              sizeof(AudioStreamBasicDescription));
     if (r != noErr) {
